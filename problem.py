import sys
import os
from tqdm import tqdm
import numpy
import matplotlib.pylab as plt
# from ahsan import create_slideshow_from_slides, create_slides_from_photos 
##
# Function to calculate aggregated interest(final score) from output generated by our algo


# Input
# 4
# H 3 cat beach sun
# V 2 selfie smile
# V 2 garden selfie
# H 2 garden cat



class Photo():
    def __init__(self, orientation, no_of_tags, tags,):
        self.orientation = orientation
        self.no_of_tags = no_of_tags
        self.tags = tags

        
class Slideshow():
    def __init__(self, slides):         
        self.slides = slides # slides is an array

    def add_slide(self, slide):
        slides.append(slide)
    
    def calculateScore(self):
        finalScore = 0
        i = 0
        while i < (len(self.slides) - 1):
            finalScore = finalScore + (self.slides[i].calculate_interest((self.slides[i + 1])))
            i = i + 1
        return finalScore
    
    def write_file(self, filename):
        ''' 
        Writes the slideshow to file. 
  
        Parameters: 
            slideshow (list): contains list of slides. 
        '''
        # print self.slides
        with open('output/'+filename, 'w') as fd:
            fd.write(str(len(self.slides)) + '\n')
            for slide in self.slides:
                # print slide.index
                slide = ' '.join([str(x) for x in slide.index])
                fd.write(slide + '\n')

    def calculate_score_after_swap(first_index,second_index):
        score =  this.slides[first_index].calculate_interest(this.slides[first_index+1])
        score += this.slides[first_index].calculate_interest(this.slides[first_index-1])
        score +=  this.slides[second_index].calculate_interest(this.slides[second_index+1])
        score += this.slides[second_index].calculate_interest(this.slides[second_index-1])
        return score

        

class Slide():
    def __init__(self, tags, index):
        self.tags = tags # list of tags
        self.index = index # id is a list
    
    
    def calculate_interest(self, nextSlide):
        return min(self.get_common_tags(nextSlide), 
            self.getExtraTagsInThisSlide(nextSlide),
            self.getExtraTagsInNextSlide(nextSlide))

    def get_common_tags(self, nextSlide):
        '''
        Returns length
        '''
        return len(list(set(self.tags) & set(nextSlide.tags))) 

    def getExtraTagsInThisSlide(self, nextSlide):
        return len(list(set(self.tags) - set(nextSlide.tags)))

    def getExtraTagsInNextSlide(self, nextSlide):
        return len(list(set(nextSlide.tags) - set(self.tags)))

def find_weak_slide(slideshow, threshold):
    '''
    Returns indices of weak slides
    '''
    print 'Finding Weak Slides...'
    weak_slides = []
    last_transition_was_weak = False
    index = 0
    for first_slide, second_slide in tqdm(zip(slideshow, slideshow[1:])):
        interest = first_slide.calculate_interest(second_slide)
        if interest < threshold:
            if last_transition_was_weak:
                weak_slides.append(index)
                last_transition_was_weak = False
            else:
                last_transition_was_weak = True
        index = index + 1
    print 'Weak Slides:',len(weak_slides)
    return weak_slides
# def remove_weakest(slideshow):
#     for slide in slideshow.slides:

def swap_slide(first, second, slideshow):
     slideshow.slides[first], slideshow.slides[second] = slideshow.slides[second], slideshow.slides[first]
     return slideshow

def handle_weak_slides(weak_slides, the_slideshow):
    candidate = weak_slides.pop()
    pbar = tqdm(total=len(weak_slides)-1)
    swapped = False
    print 'Swapping weak slides'
    while weak_slides:
        for potential_swap in weak_slides:
            prev_score = the_slideshow.calculate_score_after_swap(potential_swap, candidate)
            the_slideshow = swap_slide(candidate,potential_swap,the_slideshow)
            new_score = the_slideshow.calculate_score_after_swap(potential_swap, candidate)
            if new_score < prev_score:
                the_slideshow = swap_slide(candidate,potential_swap, the_slideshow)
            else:
                swapped = True
                print 'swapped'
                break
        if swapped:
            weak_slides.remove(potential_swap)
            pbar.update(1)
        if weak_slides:
            candidate = weak_slides.pop()
        pbar.update(1)
    pbar.close()
    return the_slideshow


def create_slideshow_from_slides(slides):
    print 'Sorting Slides...'
    slides.sort(key = lambda x: len(x.tags))
    new_slides = []
    potential_match = slides.pop()
    pbar = tqdm(total=len(slides))
    print 'Creating Optimal Slideshow...'
    while slides:
        i = 0
        highest_score = -1
        candidate = potential_match
        new_slides.append(candidate)
        for index, slide in enumerate(slides):
            i = i + 1
            score = candidate.calculate_interest(slide)
            if score > highest_score:
                highest_score = score
                potential_match = slide
                potential_index = index
            if i > 500:
                break
        if potential_match:
            # new_slides.append(potential_match)
            slides.remove(potential_match)
        pbar.update(1)
    pbar.close()
    weak_slides = find_weak_slide(new_slides, 7)
    the_slideshow = Slideshow(new_slides)
    # Not handling weak slides. Doubles the time taken, with very low improvement
    # the_slideshow = handle_weak_slides(weak_slides, the_slideshow)
    return the_slideshow

def merged_vertical(new_vertical, vertical_photos):
    if vertical_photos:
        for photo in vertical_photos:
            if len(photo['tags'].difference(new_vertical['tags'])) == 0:
                return True, photo
            else:
                return False, None
    return False, None
def force_merged(first, second):
    return [first['id']] + [second['id']] , list(first['tags'])+ list(second['tags'])

def create_slides_from_photos(photos):
    slides = []
    vertical_photos = []
    print 'Creating Slides from Photos...'
    for i, photo in enumerate(photos):
        if photo.orientation == 'H':
            slide = Slide(photo.tags, [i])
            slides.append(slide)
        else:
            new_vertical = {"tags": set(photo.tags), "id": i}
            success, matched_photo = merged_vertical(new_vertical, vertical_photos)
            if success:
                index, tags = force_merged(matched_photo, new_vertical)
                slide = Slide(tags,index)
                slides.append(slide)
                vertical_photos.pop(matched_photo)
            else:
                vertical_photos.append(new_vertical)
    while len(vertical_photos) > 1:
        first_photo = vertical_photos.pop()
        second_photo = vertical_photos.pop()
        index, tags = force_merged(first_photo,second_photo)
        slide = Slide(tags,index)
        slides.append(slide)
        
    print "Total Slides: ",len(slides)
    return slides 

def parse_input(line):
    return line[0], line[1], line[2:]

def read_file(filename):
    with open(filename) as fd:
        total = fd.readline()
        
        #index of the photo is the ID
        photos = []
        for i in tqdm(range(0,int(total))):
            line = fd.readline()[:-1].split(' ')
            orientation, no_of_tags, tags = parse_input(line)
            photo = Photo(orientation, no_of_tags, tags)
            photos.append(photo)
    print 'Total Photos:', len(photos)
    return photos

def create_table(slides):
    matrix = numpy.zeros((len(slides), len(slides)))
    for i, first_slide in tqdm(enumerate(slides)):
        for j, second_slide in enumerate(slides):
            if i == j:
                matrix[i][j] = -1
                continue
            matrix[i][j] = first_slide.calculate_interest(second_slide)
    print matrix            
    print matrix.shape
    return matrix

def slideshow_through_dp(matrix,slides):
    new_slides = []
    x, y = numpy.unravel_index(numpy.argmax(matrix, axis=None), matrix.shape)
    new_slides.append(slides[x])
    matrix[x].fill(-1)
    matrix[:,x].fill(-1)
    print matrix

    for i in range(0,len(slides)-1):
        new_slides.append(slides[y])
        x= numpy.argmax(matrix[y])
        matrix[y].fill(-1)
        matrix[:,y].fill(-1)
        y = x
    
    # print numpy.argmax(matrix, axis=0)
    plt.imshow(matrix, interpolation='nearest', cmap=plt.cm.ocean, extent=(0.5,10.5,0.5,10.5))
    plt.colorbar()
    plt.show()
        
    slideshow = Slideshow(new_slides)
    return slideshow
                                                  

def main():
    if len(sys.argv) < 2:
        print 'Enter input_file name'
        sys.exit(1)
    print 'Reading file...'
    photos = read_file(sys.argv[1]) # photo is an array of Photos
    slides = create_slides_from_photos(photos) # slides is array of slides (any order)
    matrix = create_table(slides)
    slideshow = slideshow_through_dp(matrix, slides)
    # slideshow = create_slideshow_from_slides(slides) # slideshow is array of slides (in specific order)
    slideshow.write_file(sys.argv[1].split('/')[-1])
    print 'Score: ',slideshow.calculateScore()

if __name__ == "__main__":
    main()